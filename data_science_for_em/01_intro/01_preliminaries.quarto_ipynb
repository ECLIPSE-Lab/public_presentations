{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Data Manipulation\n",
        "\n",
        "- Data handling requires two main tasks:\n",
        "  * Data acquisition\n",
        "  * Data processing\n",
        "\n",
        "- Key concepts for data manipulation:\n",
        "  * $n$-dimensional arrays (tensors) are fundamental\n",
        "  * Modern deep learning frameworks use tensor classes:\n",
        "    - `ndarray` in MXNet\n",
        "    - `Tensor` in PyTorch and TensorFlow\n",
        "    - Similar to NumPy's `ndarray` with additional features\n",
        "  * Key advantages of tensor classes:\n",
        "    - Support automatic differentiation\n",
        "    - GPU acceleration for numerical computation\n",
        "    - NumPy only runs on CPUs\n",
        "\n",
        "## Getting Started 1\n",
        "\n",
        "- Import PyTorch:"
      ],
      "id": "c791df00"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import torch"
      ],
      "id": "a9990f1d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- Tensor basics:\n",
        "  * Vector: tensor with one axis\n",
        "  * Matrix: tensor with two axes\n",
        "  * $k^\\mathrm{th}$ order tensor: tensor with $k > 2$ axes\n",
        "\n",
        "- Tensor creation:\n",
        "  * Use `arange(n)` for evenly spaced values (0 to n-1)\n",
        "  * Default storage: main memory\n",
        "  * Default computation: CPU-based\n",
        "\n",
        "## Getting Started 2\n"
      ],
      "id": "dea7877c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = torch.arange(12, dtype=torch.float32)\n",
        "x"
      ],
      "id": "d5df8229",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- Tensor elements:\n",
        "  * Each value is an element\n",
        "  * Use `numel()` to get total element count\n",
        "  * Use `shape` attribute to get dimensions\n"
      ],
      "id": "defe81ea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x.numel()\n",
        "x.shape"
      ],
      "id": "31a8bdd4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- Reshaping tensors:\n",
        "  * Use `reshape` to change shape without changing values\n",
        "  * Example: vector (12,) → matrix (3, 4)\n",
        "  * Elements maintain order (row-major)\n"
      ],
      "id": "bed9cb08"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X = x.reshape(3, 4)\n",
        "X"
      ],
      "id": "7175c2ef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Getting Started 3\n",
        "\n",
        "- Shape inference:\n",
        "  * Use `-1` to automatically infer one dimension\n",
        "  * Example: `x.reshape(-1, 4)` or `x.reshape(3, -1)`\n",
        "  * Given size $n$ and shape ($h$, $w$), $w = n/h$\n",
        "\n",
        "- Common tensor initializations:\n",
        "  * Zeros: `torch.zeros((2, 3, 4))`\n",
        "  * Ones: `torch.ones((2, 3, 4))`\n",
        "  * Random (Gaussian): `torch.randn(3, 4)`\n",
        "  * Custom values: `torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])`\n",
        "\n",
        "## Indexing and Slicing 1\n",
        "\n",
        "- Access methods:\n",
        "  * Indexing (0-based)\n",
        "  * Negative indexing (from end)\n",
        "  * Slicing (`start:stop`)\n",
        "  * Single index/slice applies to axis 0\n"
      ],
      "id": "49f45ba8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X[-1], X[1:3]"
      ],
      "id": "ee642b48",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- Element modification:\n",
        "  * Use indexing for assignment\n",
        "  * Example: `X[1, 2] = 17`\n",
        "\n",
        "## Indexing and Slicing 2\n",
        "\n",
        "- Multiple element assignment:\n",
        "  * Use indexing on left side of assignment\n",
        "  * `:` selects all elements along an axis\n",
        "  * Works for vectors and higher-dimensional tensors\n"
      ],
      "id": "2dbea837"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X[:2, :] = 12\n",
        "X"
      ],
      "id": "00bd959f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Operations 1\n",
        "\n",
        "- Elementwise operations:\n",
        "  * Apply scalar operations to each element\n",
        "  * Work with corresponding element pairs\n",
        "  * Support unary operators (e.g., $e^x$)\n",
        "  * Signature: $f: \\mathbb{R} \\rightarrow \\mathbb{R}$\n"
      ],
      "id": "0386510f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "torch.exp(x)"
      ],
      "id": "64815609",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Operations 2\n",
        "\n",
        "- Binary operations:\n",
        "  * Work on pairs of real numbers\n",
        "  * Signature: $f: \\mathbb{R}, \\mathbb{R} \\rightarrow \\mathbb{R}$\n",
        "  * Common operators:\n",
        "    - Addition (`+`)\n",
        "    - Subtraction (`-`)\n",
        "    - Multiplication (`*`)\n",
        "    - Division (`/`)\n",
        "    - Exponentiation (`**`)\n"
      ],
      "id": "bdb4a04d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = torch.tensor([1.0, 2, 4, 8])\n",
        "y = torch.tensor([2, 2, 2, 2])\n",
        "x + y, x - y, x * y, x / y, x ** y"
      ],
      "id": "18526b61",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Operations 3\n",
        "\n",
        "- Tensor concatenation:\n",
        "  * Use `torch.cat` with list of tensors\n",
        "  * Specify axis for concatenation\n",
        "  * Shape changes:\n",
        "    - Axis 0: sum of input axis-0 lengths\n",
        "    - Axis 1: sum of input axis-1 lengths\n"
      ],
      "id": "35475a45"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X = torch.arange(12, dtype=torch.float32).reshape((3,4))\n",
        "Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])\n",
        "torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)"
      ],
      "id": "8046ab1d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Operations 4\n",
        "\n",
        "- Logical operations:\n",
        "  * Create binary tensors via logical statements\n",
        "  * Example: `X == Y` creates tensor of 1s and 0s\n",
        "  * Sum operation: `X.sum()` reduces to single element\n"
      ],
      "id": "4a98ddb7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X == Y\n",
        "X.sum()"
      ],
      "id": "2a3676ce",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Broadcasting\n",
        "\n",
        "- Mechanism for elementwise operations with different shapes:\n",
        "  * Step 1: Expand arrays along length-1 axes\n",
        "  * Step 2: Perform elementwise operation\n"
      ],
      "id": "01d28c7b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "a = torch.arange(3).reshape((3, 1))\n",
        "b = torch.arange(2).reshape((1, 2))\n",
        "a + b"
      ],
      "id": "460f66ac",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Saving Memory 1\n",
        "\n",
        "- Memory allocation issues:\n",
        "  * Operations create new memory allocations\n",
        "  * Example: `Y = X + Y` creates new memory\n",
        "  * Check with `id()` function\n",
        "  * Undesirable for:\n",
        "    - Frequent parameter updates\n",
        "    - Multiple variable references\n",
        "\n",
        "## Saving Memory 2\n",
        "\n",
        "- In-place operations:\n",
        "  * Use slice notation: `Y[:] = <expression>`\n",
        "  * Use `zeros_like` for initialization\n",
        "  * Use `X[:] = X + Y` or `X += Y` for efficiency\n"
      ],
      "id": "101b3d03"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "Z = torch.zeros_like(Y)\n",
        "Z[:] = X + Y\n",
        "X += Y"
      ],
      "id": "b989b0c9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Conversion to Other Python Objects\n",
        "\n",
        "- NumPy conversion:\n",
        "  * `X.numpy()`: Tensor → NumPy array\n",
        "  * `torch.from_numpy(A)`: NumPy array → Tensor\n",
        "  * Shared memory between conversions\n",
        "\n",
        "- Scalar conversion:\n",
        "  * Use `item()` or built-in functions\n",
        "  * Example: `float(a)`, `int(a)`\n",
        "\n",
        "## Summary\n",
        "\n",
        "- Tensor class features:\n",
        "  * Data storage and manipulation\n",
        "  * Construction routines\n",
        "  * Indexing and slicing\n",
        "  * Basic mathematics\n",
        "  * Broadcasting\n",
        "  * Memory-efficient operations\n",
        "  * Python object conversion\n",
        "\n",
        "## Exercises\n",
        "\n",
        "1. Experiment with different conditional statements:\n",
        "   * Try `X < Y` and `X > Y`\n",
        "   * Observe resulting tensor types\n",
        "\n",
        "2. Test broadcasting with 3D tensors:\n",
        "   * Try different shapes\n",
        "   * Verify results match expectations\n"
      ],
      "id": "9a1ad617"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/usr/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}